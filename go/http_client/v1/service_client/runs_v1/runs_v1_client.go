// Copyright 2018-2022 Polyaxon, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by go-swagger; DO NOT EDIT.

package runs_v1

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new runs v1 API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for runs v1 API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	ApproveRun(params *ApproveRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ApproveRunOK, *ApproveRunNoContent, error)

	ApproveRuns(params *ApproveRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ApproveRunsOK, *ApproveRunsNoContent, error)

	ArchiveRun(params *ArchiveRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ArchiveRunOK, *ArchiveRunNoContent, error)

	ArchiveRuns(params *ArchiveRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ArchiveRunsOK, *ArchiveRunsNoContent, error)

	BookmarkRun(params *BookmarkRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BookmarkRunOK, *BookmarkRunNoContent, error)

	BookmarkRuns(params *BookmarkRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BookmarkRunsOK, *BookmarkRunsNoContent, error)

	CollectRunLogs(params *CollectRunLogsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CollectRunLogsOK, *CollectRunLogsNoContent, error)

	CopyRun(params *CopyRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CopyRunOK, *CopyRunNoContent, error)

	CreateRun(params *CreateRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRunOK, *CreateRunNoContent, error)

	CreateRunArtifactsLineage(params *CreateRunArtifactsLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRunArtifactsLineageOK, *CreateRunArtifactsLineageNoContent, error)

	CreateRunStatus(params *CreateRunStatusParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRunStatusOK, *CreateRunStatusNoContent, error)

	DeleteRun(params *DeleteRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteRunOK, *DeleteRunNoContent, error)

	DeleteRunArtifact(params *DeleteRunArtifactParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteRunArtifactOK, *DeleteRunArtifactNoContent, error)

	DeleteRunArtifactLineage(params *DeleteRunArtifactLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteRunArtifactLineageOK, *DeleteRunArtifactLineageNoContent, error)

	DeleteRunArtifacts(params *DeleteRunArtifactsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteRunArtifactsOK, *DeleteRunArtifactsNoContent, error)

	DeleteRuns(params *DeleteRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteRunsOK, *DeleteRunsNoContent, error)

	GetMultiRunEvents(params *GetMultiRunEventsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMultiRunEventsOK, *GetMultiRunEventsNoContent, error)

	GetRun(params *GetRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunOK, *GetRunNoContent, error)

	GetRunArtifact(params *GetRunArtifactParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunArtifactOK, *GetRunArtifactNoContent, error)

	GetRunArtifactLineage(params *GetRunArtifactLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunArtifactLineageOK, *GetRunArtifactLineageNoContent, error)

	GetRunArtifacts(params *GetRunArtifactsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunArtifactsOK, *GetRunArtifactsNoContent, error)

	GetRunArtifactsLineage(params *GetRunArtifactsLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunArtifactsLineageOK, *GetRunArtifactsLineageNoContent, error)

	GetRunArtifactsLineageNames(params *GetRunArtifactsLineageNamesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunArtifactsLineageNamesOK, *GetRunArtifactsLineageNamesNoContent, error)

	GetRunArtifactsTree(params *GetRunArtifactsTreeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunArtifactsTreeOK, *GetRunArtifactsTreeNoContent, error)

	GetRunClonesLineage(params *GetRunClonesLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunClonesLineageOK, *GetRunClonesLineageNoContent, error)

	GetRunConnectionsLineage(params *GetRunConnectionsLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunConnectionsLineageOK, *GetRunConnectionsLineageNoContent, error)

	GetRunDownstreamLineage(params *GetRunDownstreamLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunDownstreamLineageOK, *GetRunDownstreamLineageNoContent, error)

	GetRunEvents(params *GetRunEventsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunEventsOK, *GetRunEventsNoContent, error)

	GetRunLogs(params *GetRunLogsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunLogsOK, *GetRunLogsNoContent, error)

	GetRunNamespace(params *GetRunNamespaceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunNamespaceOK, *GetRunNamespaceNoContent, error)

	GetRunResources(params *GetRunResourcesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunResourcesOK, *GetRunResourcesNoContent, error)

	GetRunSettings(params *GetRunSettingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunSettingsOK, *GetRunSettingsNoContent, error)

	GetRunStats(params *GetRunStatsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunStatsOK, *GetRunStatsNoContent, error)

	GetRunStatuses(params *GetRunStatusesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunStatusesOK, *GetRunStatusesNoContent, error)

	GetRunUpstreamLineage(params *GetRunUpstreamLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunUpstreamLineageOK, *GetRunUpstreamLineageNoContent, error)

	GetRunsArtifactsLineage(params *GetRunsArtifactsLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunsArtifactsLineageOK, *GetRunsArtifactsLineageNoContent, error)

	ImpersonateToken(params *ImpersonateTokenParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ImpersonateTokenOK, *ImpersonateTokenNoContent, error)

	InspectRun(params *InspectRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*InspectRunOK, *InspectRunNoContent, error)

	InvalidateRun(params *InvalidateRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*InvalidateRunOK, *InvalidateRunNoContent, error)

	InvalidateRuns(params *InvalidateRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*InvalidateRunsOK, *InvalidateRunsNoContent, error)

	ListArchivedRuns(params *ListArchivedRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListArchivedRunsOK, *ListArchivedRunsNoContent, error)

	ListBookmarkedRuns(params *ListBookmarkedRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListBookmarkedRunsOK, *ListBookmarkedRunsNoContent, error)

	ListRuns(params *ListRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListRunsOK, *ListRunsNoContent, error)

	NotifyRunStatus(params *NotifyRunStatusParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NotifyRunStatusOK, *NotifyRunStatusNoContent, error)

	PatchRun(params *PatchRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PatchRunOK, *PatchRunNoContent, error)

	RestartRun(params *RestartRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RestartRunOK, *RestartRunNoContent, error)

	RestoreRun(params *RestoreRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RestoreRunOK, *RestoreRunNoContent, error)

	RestoreRuns(params *RestoreRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RestoreRunsOK, *RestoreRunsNoContent, error)

	ResumeRun(params *ResumeRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ResumeRunOK, *ResumeRunNoContent, error)

	StopRun(params *StopRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*StopRunOK, *StopRunNoContent, error)

	StopRuns(params *StopRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*StopRunsOK, *StopRunsNoContent, error)

	SyncRun(params *SyncRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SyncRunOK, *SyncRunNoContent, error)

	TagRuns(params *TagRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*TagRunsOK, *TagRunsNoContent, error)

	TransferRun(params *TransferRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*TransferRunOK, *TransferRunNoContent, error)

	TransferRuns(params *TransferRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*TransferRunsOK, *TransferRunsNoContent, error)

	UnbookmarkRun(params *UnbookmarkRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnbookmarkRunOK, *UnbookmarkRunNoContent, error)

	UpdateRun(params *UpdateRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRunOK, *UpdateRunNoContent, error)

	UploadRunArtifact(params *UploadRunArtifactParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UploadRunArtifactOK, *UploadRunArtifactNoContent, error)

	UploadRunLogs(params *UploadRunLogsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UploadRunLogsOK, *UploadRunLogsNoContent, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  ApproveRun approves run
*/
func (a *Client) ApproveRun(params *ApproveRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ApproveRunOK, *ApproveRunNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewApproveRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ApproveRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/approve",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ApproveRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ApproveRunOK:
		return value, nil, nil
	case *ApproveRunNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ApproveRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ApproveRuns approves runs
*/
func (a *Client) ApproveRuns(params *ApproveRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ApproveRunsOK, *ApproveRunsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewApproveRunsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ApproveRuns",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/approve",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ApproveRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ApproveRunsOK:
		return value, nil, nil
	case *ApproveRunsNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ApproveRunsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ArchiveRun archives run
*/
func (a *Client) ArchiveRun(params *ArchiveRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ArchiveRunOK, *ArchiveRunNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewArchiveRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ArchiveRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/archive",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ArchiveRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ArchiveRunOK:
		return value, nil, nil
	case *ArchiveRunNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ArchiveRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ArchiveRuns archives runs
*/
func (a *Client) ArchiveRuns(params *ArchiveRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ArchiveRunsOK, *ArchiveRunsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewArchiveRunsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ArchiveRuns",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/archive",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ArchiveRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ArchiveRunsOK:
		return value, nil, nil
	case *ArchiveRunsNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ArchiveRunsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  BookmarkRun bookmarks run
*/
func (a *Client) BookmarkRun(params *BookmarkRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BookmarkRunOK, *BookmarkRunNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBookmarkRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "BookmarkRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/bookmark",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &BookmarkRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *BookmarkRunOK:
		return value, nil, nil
	case *BookmarkRunNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*BookmarkRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  BookmarkRuns bookmarks runs
*/
func (a *Client) BookmarkRuns(params *BookmarkRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*BookmarkRunsOK, *BookmarkRunsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewBookmarkRunsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "BookmarkRuns",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/bookmark",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &BookmarkRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *BookmarkRunsOK:
		return value, nil, nil
	case *BookmarkRunsNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*BookmarkRunsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CollectRunLogs collects run logs
*/
func (a *Client) CollectRunLogs(params *CollectRunLogsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CollectRunLogsOK, *CollectRunLogsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCollectRunLogsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CollectRunLogs",
		Method:             "POST",
		PathPattern:        "/streams/v1/{namespace}/_internal/{owner}/{project}/runs/{uuid}/{kind}/logs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CollectRunLogsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *CollectRunLogsOK:
		return value, nil, nil
	case *CollectRunLogsNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CollectRunLogsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CopyRun restarts run with copy
*/
func (a *Client) CopyRun(params *CopyRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CopyRunOK, *CopyRunNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCopyRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CopyRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{run.uuid}/copy",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CopyRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *CopyRunOK:
		return value, nil, nil
	case *CopyRunNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CopyRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateRun creates new run
*/
func (a *Client) CreateRun(params *CreateRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRunOK, *CreateRunNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *CreateRunOK:
		return value, nil, nil
	case *CreateRunNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateRunArtifactsLineage creates bulk run artifacts lineage
*/
func (a *Client) CreateRunArtifactsLineage(params *CreateRunArtifactsLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRunArtifactsLineageOK, *CreateRunArtifactsLineageNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateRunArtifactsLineageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateRunArtifactsLineage",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}/lineage/artifacts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateRunArtifactsLineageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *CreateRunArtifactsLineageOK:
		return value, nil, nil
	case *CreateRunArtifactsLineageNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateRunArtifactsLineageDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  CreateRunStatus creates new run status
*/
func (a *Client) CreateRunStatus(params *CreateRunStatusParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRunStatusOK, *CreateRunStatusNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateRunStatusParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateRunStatus",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}/statuses",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateRunStatusReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *CreateRunStatusOK:
		return value, nil, nil
	case *CreateRunStatusNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateRunStatusDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteRun deletes run
*/
func (a *Client) DeleteRun(params *DeleteRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteRunOK, *DeleteRunNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteRun",
		Method:             "DELETE",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteRunOK:
		return value, nil, nil
	case *DeleteRunNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteRunArtifact deletes run artifact
*/
func (a *Client) DeleteRunArtifact(params *DeleteRunArtifactParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteRunArtifactOK, *DeleteRunArtifactNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteRunArtifactParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteRunArtifact",
		Method:             "DELETE",
		PathPattern:        "/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/artifact",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteRunArtifactReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteRunArtifactOK:
		return value, nil, nil
	case *DeleteRunArtifactNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteRunArtifactDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteRunArtifactLineage deletes run artifact lineage
*/
func (a *Client) DeleteRunArtifactLineage(params *DeleteRunArtifactLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteRunArtifactLineageOK, *DeleteRunArtifactLineageNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteRunArtifactLineageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteRunArtifactLineage",
		Method:             "DELETE",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}/lineage/artifacts/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteRunArtifactLineageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteRunArtifactLineageOK:
		return value, nil, nil
	case *DeleteRunArtifactLineageNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteRunArtifactLineageDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteRunArtifacts deletes run artifacts
*/
func (a *Client) DeleteRunArtifacts(params *DeleteRunArtifactsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteRunArtifactsOK, *DeleteRunArtifactsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteRunArtifactsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteRunArtifacts",
		Method:             "DELETE",
		PathPattern:        "/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/artifacts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteRunArtifactsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteRunArtifactsOK:
		return value, nil, nil
	case *DeleteRunArtifactsNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteRunArtifactsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  DeleteRuns deletes runs
*/
func (a *Client) DeleteRuns(params *DeleteRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteRunsOK, *DeleteRunsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteRunsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteRuns",
		Method:             "DELETE",
		PathPattern:        "/api/v1/{owner}/{project}/runs/delete",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteRunsOK:
		return value, nil, nil
	case *DeleteRunsNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteRunsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetMultiRunEvents gets multi runs events
*/
func (a *Client) GetMultiRunEvents(params *GetMultiRunEventsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMultiRunEventsOK, *GetMultiRunEventsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMultiRunEventsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetMultiRunEvents",
		Method:             "GET",
		PathPattern:        "/streams/v1/{namespace}/{owner}/{project}/runs/multi/events/{kind}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMultiRunEventsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetMultiRunEventsOK:
		return value, nil, nil
	case *GetMultiRunEventsNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetMultiRunEventsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetRun gets run
*/
func (a *Client) GetRun(params *GetRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunOK, *GetRunNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRun",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetRunOK:
		return value, nil, nil
	case *GetRunNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetRunArtifact gets run artifact
*/
func (a *Client) GetRunArtifact(params *GetRunArtifactParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunArtifactOK, *GetRunArtifactNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRunArtifactParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunArtifact",
		Method:             "GET",
		PathPattern:        "/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/artifact",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunArtifactReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetRunArtifactOK:
		return value, nil, nil
	case *GetRunArtifactNoContent:
		return nil, value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for runs_v1: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetRunArtifactLineage gets run artifacts lineage
*/
func (a *Client) GetRunArtifactLineage(params *GetRunArtifactLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunArtifactLineageOK, *GetRunArtifactLineageNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRunArtifactLineageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunArtifactLineage",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}/lineage/artifacts/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunArtifactLineageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetRunArtifactLineageOK:
		return value, nil, nil
	case *GetRunArtifactLineageNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRunArtifactLineageDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetRunArtifacts gets run artifacts
*/
func (a *Client) GetRunArtifacts(params *GetRunArtifactsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunArtifactsOK, *GetRunArtifactsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRunArtifactsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunArtifacts",
		Method:             "GET",
		PathPattern:        "/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/artifacts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunArtifactsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetRunArtifactsOK:
		return value, nil, nil
	case *GetRunArtifactsNoContent:
		return nil, value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for runs_v1: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetRunArtifactsLineage gets run artifacts lineage
*/
func (a *Client) GetRunArtifactsLineage(params *GetRunArtifactsLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunArtifactsLineageOK, *GetRunArtifactsLineageNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRunArtifactsLineageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunArtifactsLineage",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/lineage/artifacts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunArtifactsLineageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetRunArtifactsLineageOK:
		return value, nil, nil
	case *GetRunArtifactsLineageNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRunArtifactsLineageDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetRunArtifactsLineageNames gets run artifacts lineage names
*/
func (a *Client) GetRunArtifactsLineageNames(params *GetRunArtifactsLineageNamesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunArtifactsLineageNamesOK, *GetRunArtifactsLineageNamesNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRunArtifactsLineageNamesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunArtifactsLineageNames",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/lineage/artifacts/names",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunArtifactsLineageNamesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetRunArtifactsLineageNamesOK:
		return value, nil, nil
	case *GetRunArtifactsLineageNamesNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRunArtifactsLineageNamesDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetRunArtifactsTree gets run artifacts tree
*/
func (a *Client) GetRunArtifactsTree(params *GetRunArtifactsTreeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunArtifactsTreeOK, *GetRunArtifactsTreeNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRunArtifactsTreeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunArtifactsTree",
		Method:             "GET",
		PathPattern:        "/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/artifacts/tree",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunArtifactsTreeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetRunArtifactsTreeOK:
		return value, nil, nil
	case *GetRunArtifactsTreeNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRunArtifactsTreeDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetRunClonesLineage gets run clones lineage
*/
func (a *Client) GetRunClonesLineage(params *GetRunClonesLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunClonesLineageOK, *GetRunClonesLineageNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRunClonesLineageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunClonesLineage",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/lineage/clones",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunClonesLineageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetRunClonesLineageOK:
		return value, nil, nil
	case *GetRunClonesLineageNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRunClonesLineageDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetRunConnectionsLineage gets run connections lineage
*/
func (a *Client) GetRunConnectionsLineage(params *GetRunConnectionsLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunConnectionsLineageOK, *GetRunConnectionsLineageNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRunConnectionsLineageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunConnectionsLineage",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/lineage/connections",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunConnectionsLineageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetRunConnectionsLineageOK:
		return value, nil, nil
	case *GetRunConnectionsLineageNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRunConnectionsLineageDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetRunDownstreamLineage gets run downstream lineage
*/
func (a *Client) GetRunDownstreamLineage(params *GetRunDownstreamLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunDownstreamLineageOK, *GetRunDownstreamLineageNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRunDownstreamLineageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunDownstreamLineage",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/lineage/downstream",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunDownstreamLineageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetRunDownstreamLineageOK:
		return value, nil, nil
	case *GetRunDownstreamLineageNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRunDownstreamLineageDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetRunEvents gets run events
*/
func (a *Client) GetRunEvents(params *GetRunEventsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunEventsOK, *GetRunEventsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRunEventsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunEvents",
		Method:             "GET",
		PathPattern:        "/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/events/{kind}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunEventsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetRunEventsOK:
		return value, nil, nil
	case *GetRunEventsNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRunEventsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetRunLogs gets run logs
*/
func (a *Client) GetRunLogs(params *GetRunLogsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunLogsOK, *GetRunLogsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRunLogsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunLogs",
		Method:             "GET",
		PathPattern:        "/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/logs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunLogsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetRunLogsOK:
		return value, nil, nil
	case *GetRunLogsNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRunLogsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetRunNamespace gets run namespace
*/
func (a *Client) GetRunNamespace(params *GetRunNamespaceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunNamespaceOK, *GetRunNamespaceNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRunNamespaceParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunNamespace",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/namespace",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunNamespaceReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetRunNamespaceOK:
		return value, nil, nil
	case *GetRunNamespaceNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRunNamespaceDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetRunResources gets run resources events
*/
func (a *Client) GetRunResources(params *GetRunResourcesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunResourcesOK, *GetRunResourcesNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRunResourcesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunResources",
		Method:             "GET",
		PathPattern:        "/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/resources",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunResourcesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetRunResourcesOK:
		return value, nil, nil
	case *GetRunResourcesNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRunResourcesDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetRunSettings gets run settings
*/
func (a *Client) GetRunSettings(params *GetRunSettingsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunSettingsOK, *GetRunSettingsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRunSettingsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunSettings",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/settings",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunSettingsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetRunSettingsOK:
		return value, nil, nil
	case *GetRunSettingsNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRunSettingsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetRunStats gets run stats
*/
func (a *Client) GetRunStats(params *GetRunStatsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunStatsOK, *GetRunStatsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRunStatsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunStats",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/stats",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunStatsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetRunStatsOK:
		return value, nil, nil
	case *GetRunStatsNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRunStatsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetRunStatuses gets run statuses
*/
func (a *Client) GetRunStatuses(params *GetRunStatusesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunStatusesOK, *GetRunStatusesNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRunStatusesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunStatuses",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/statuses",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunStatusesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetRunStatusesOK:
		return value, nil, nil
	case *GetRunStatusesNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRunStatusesDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetRunUpstreamLineage gets run upstream lineage
*/
func (a *Client) GetRunUpstreamLineage(params *GetRunUpstreamLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunUpstreamLineageOK, *GetRunUpstreamLineageNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRunUpstreamLineageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunUpstreamLineage",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/lineage/upstream",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunUpstreamLineageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetRunUpstreamLineageOK:
		return value, nil, nil
	case *GetRunUpstreamLineageNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRunUpstreamLineageDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  GetRunsArtifactsLineage gets runs artifacts lineage
*/
func (a *Client) GetRunsArtifactsLineage(params *GetRunsArtifactsLineageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRunsArtifactsLineageOK, *GetRunsArtifactsLineageNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRunsArtifactsLineageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRunsArtifactsLineage",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{name}/runs/lineage/artifacts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetRunsArtifactsLineageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetRunsArtifactsLineageOK:
		return value, nil, nil
	case *GetRunsArtifactsLineageNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRunsArtifactsLineageDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ImpersonateToken impersonates run token
*/
func (a *Client) ImpersonateToken(params *ImpersonateTokenParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ImpersonateTokenOK, *ImpersonateTokenNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImpersonateTokenParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ImpersonateToken",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/impersonate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImpersonateTokenReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ImpersonateTokenOK:
		return value, nil, nil
	case *ImpersonateTokenNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ImpersonateTokenDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  InspectRun inspects an active run full conditions
*/
func (a *Client) InspectRun(params *InspectRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*InspectRunOK, *InspectRunNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewInspectRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "InspectRun",
		Method:             "GET",
		PathPattern:        "/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/k8s_inspect",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &InspectRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *InspectRunOK:
		return value, nil, nil
	case *InspectRunNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*InspectRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  InvalidateRun invalidates run
*/
func (a *Client) InvalidateRun(params *InvalidateRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*InvalidateRunOK, *InvalidateRunNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewInvalidateRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "InvalidateRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/invalidate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &InvalidateRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *InvalidateRunOK:
		return value, nil, nil
	case *InvalidateRunNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*InvalidateRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  InvalidateRuns invalidates runs
*/
func (a *Client) InvalidateRuns(params *InvalidateRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*InvalidateRunsOK, *InvalidateRunsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewInvalidateRunsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "InvalidateRuns",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/invalidate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &InvalidateRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *InvalidateRunsOK:
		return value, nil, nil
	case *InvalidateRunsNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*InvalidateRunsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ListArchivedRuns lists archived runs for user
*/
func (a *Client) ListArchivedRuns(params *ListArchivedRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListArchivedRunsOK, *ListArchivedRunsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListArchivedRunsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListArchivedRuns",
		Method:             "GET",
		PathPattern:        "/api/v1/archives/{user}/runs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListArchivedRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ListArchivedRunsOK:
		return value, nil, nil
	case *ListArchivedRunsNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListArchivedRunsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ListBookmarkedRuns lists bookmarked runs for user
*/
func (a *Client) ListBookmarkedRuns(params *ListBookmarkedRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListBookmarkedRunsOK, *ListBookmarkedRunsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListBookmarkedRunsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListBookmarkedRuns",
		Method:             "GET",
		PathPattern:        "/api/v1/bookmarks/{user}/runs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListBookmarkedRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ListBookmarkedRunsOK:
		return value, nil, nil
	case *ListBookmarkedRunsNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListBookmarkedRunsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ListRuns lists runs
*/
func (a *Client) ListRuns(params *ListRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListRunsOK, *ListRunsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListRunsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListRuns",
		Method:             "GET",
		PathPattern:        "/api/v1/{owner}/{name}/runs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ListRunsOK:
		return value, nil, nil
	case *ListRunsNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListRunsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  NotifyRunStatus notifies run status
*/
func (a *Client) NotifyRunStatus(params *NotifyRunStatusParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NotifyRunStatusOK, *NotifyRunStatusNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNotifyRunStatusParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "NotifyRunStatus",
		Method:             "POST",
		PathPattern:        "/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/notify",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &NotifyRunStatusReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *NotifyRunStatusOK:
		return value, nil, nil
	case *NotifyRunStatusNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*NotifyRunStatusDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  PatchRun patches run
*/
func (a *Client) PatchRun(params *PatchRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PatchRunOK, *PatchRunNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "PatchRun",
		Method:             "PATCH",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{run.uuid}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PatchRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PatchRunOK:
		return value, nil, nil
	case *PatchRunNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PatchRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  RestartRun restarts run
*/
func (a *Client) RestartRun(params *RestartRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RestartRunOK, *RestartRunNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRestartRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RestartRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{run.uuid}/restart",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RestartRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *RestartRunOK:
		return value, nil, nil
	case *RestartRunNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*RestartRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  RestoreRun restores run
*/
func (a *Client) RestoreRun(params *RestoreRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RestoreRunOK, *RestoreRunNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRestoreRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RestoreRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/restore",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RestoreRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *RestoreRunOK:
		return value, nil, nil
	case *RestoreRunNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*RestoreRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  RestoreRuns restores runs
*/
func (a *Client) RestoreRuns(params *RestoreRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RestoreRunsOK, *RestoreRunsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRestoreRunsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RestoreRuns",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/restore",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RestoreRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *RestoreRunsOK:
		return value, nil, nil
	case *RestoreRunsNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*RestoreRunsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  ResumeRun resumes run
*/
func (a *Client) ResumeRun(params *ResumeRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ResumeRunOK, *ResumeRunNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewResumeRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ResumeRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{run.uuid}/resume",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ResumeRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ResumeRunOK:
		return value, nil, nil
	case *ResumeRunNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ResumeRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  StopRun stops run
*/
func (a *Client) StopRun(params *StopRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*StopRunOK, *StopRunNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewStopRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "StopRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/stop",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &StopRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *StopRunOK:
		return value, nil, nil
	case *StopRunNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*StopRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  StopRuns stops runs
*/
func (a *Client) StopRuns(params *StopRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*StopRunsOK, *StopRunsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewStopRunsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "StopRuns",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/stop",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &StopRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *StopRunsOK:
		return value, nil, nil
	case *StopRunsNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*StopRunsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  SyncRun syncs offline run
*/
func (a *Client) SyncRun(params *SyncRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SyncRunOK, *SyncRunNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSyncRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "SyncRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/sync",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &SyncRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *SyncRunOK:
		return value, nil, nil
	case *SyncRunNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SyncRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  TagRuns tags runs
*/
func (a *Client) TagRuns(params *TagRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*TagRunsOK, *TagRunsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTagRunsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "TagRuns",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/tag",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &TagRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *TagRunsOK:
		return value, nil, nil
	case *TagRunsNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*TagRunsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  TransferRun transfers run
*/
func (a *Client) TransferRun(params *TransferRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*TransferRunOK, *TransferRunNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTransferRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "TransferRun",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{run.uuid}/transfer",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &TransferRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *TransferRunOK:
		return value, nil, nil
	case *TransferRunNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*TransferRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  TransferRuns transfers runs
*/
func (a *Client) TransferRuns(params *TransferRunsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*TransferRunsOK, *TransferRunsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTransferRunsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "TransferRuns",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/transfer",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &TransferRunsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *TransferRunsOK:
		return value, nil, nil
	case *TransferRunsNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*TransferRunsDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UnbookmarkRun unbookmarks run
*/
func (a *Client) UnbookmarkRun(params *UnbookmarkRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UnbookmarkRunOK, *UnbookmarkRunNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUnbookmarkRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UnbookmarkRun",
		Method:             "DELETE",
		PathPattern:        "/api/v1/{owner}/{entity}/runs/{uuid}/unbookmark",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UnbookmarkRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *UnbookmarkRunOK:
		return value, nil, nil
	case *UnbookmarkRunNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UnbookmarkRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UpdateRun updates run
*/
func (a *Client) UpdateRun(params *UpdateRunParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRunOK, *UpdateRunNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateRunParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateRun",
		Method:             "PUT",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{run.uuid}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateRunReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *UpdateRunOK:
		return value, nil, nil
	case *UpdateRunNoContent:
		return nil, value, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateRunDefault)
	return nil, nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
  UploadRunArtifact uploads an artifact file to a store via run access
*/
func (a *Client) UploadRunArtifact(params *UploadRunArtifactParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UploadRunArtifactOK, *UploadRunArtifactNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUploadRunArtifactParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UploadRunArtifact",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}/artifacts/upload",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UploadRunArtifactReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *UploadRunArtifactOK:
		return value, nil, nil
	case *UploadRunArtifactNoContent:
		return nil, value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for runs_v1: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  UploadRunLogs uploads a logs file to a store via run access
*/
func (a *Client) UploadRunLogs(params *UploadRunLogsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UploadRunLogsOK, *UploadRunLogsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUploadRunLogsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UploadRunLogs",
		Method:             "POST",
		PathPattern:        "/api/v1/{owner}/{project}/runs/{uuid}/logs/upload",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UploadRunLogsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *UploadRunLogsOK:
		return value, nil, nil
	case *UploadRunLogsNoContent:
		return nil, value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for runs_v1: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
